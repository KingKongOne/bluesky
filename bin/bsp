#!/usr/bin/env python

"""bsp: Runs BlueSky

Example calls:
 > bsp -i fires-before.json -o fires-after.json
 > cat fires-before.json | bsp > fires-after.json
 > bsp < fires-before.json > fires-after.json
"""

import json
import importlib
import logging
import sys
import traceback

from pyairfire import scripting, process

try:
    from bluesky import exceptions, configuration, modules, models, __version__
except:
    import os
    root_dir = os.path.abspath(os.path.join(sys.path[0], '../'))
    sys.path.insert(0, root_dir)
    from bluesky import exceptions, configuration, modules, models, __version__

__author__ = "Joel Dubowy"
__copyright__ = "Copyright 2016, AirFire, PNW, USFS"

REQUIRED_ARGS = []

OPTIONAL_ARGS = [
    {
        'short': '-i',
        'long': '--input-file',
        'dest': 'input_file',
        'help': 'input file comtaining JSON formatted fire data',
        'action': "store",
        'default': None
    },
    {
        'short': '-o',
        'long': '--output-file',
        'dest': 'output_file',
        'help': 'output file comtaining JSON formatted fire data',
        'action': "store",
        'default': None
    },
    {
        'short': "-C",
        'long': '--config-option',
        'dest': 'config_options',
        'help': "Config option override, formatted like 'section.*.key=stringvalue'",
        'action': configuration.ConfigOptionAction
    },
    {
        'short': "-B",
        'long': '--boolean-config-option',
        'dest': 'config_options',
        'help': "Config option override, formatted like 'section.*.key=boolvalue'",
        'action': configuration.BooleanConfigOptionAction
    },
    {
        'short': "-I",
        'long': '--integer-config-option',
        'dest': 'config_options',
        'help': "Config option override, formatted like 'section.*.key=intvalue'",
        'action': configuration.IntegerConfigOptionAction
    },
    {
        'short': "-F",
        'long': '--float-config-option',
        'dest': 'config_options',
        'help': "Config option override, formatted like 'section.*.key=floatvalue'",
        'action': configuration.FloatConfigOptionAction
    },
    {
        'short': "-J",
        'long': '--json-config-option',
        'dest': 'config_options',
        'help': "Config option override supporting any json formatted value, formatted like 'section.*.key=jsonvalue'",
        'action': configuration.JSONConfigOptionAction
    },
    {
        'short': '-c',
        'long': '--config-file',
        'dest': 'config_file_options',
        'help': 'config file comtaining JSON formatted overrides for default config values',
        'action': configuration.ConfigFileAction
    },
    {
        #'short': "-v",
        'long': '--version',
        'dest': 'version',
        'action': 'store_true',
        'help': "Output bluesky version and exit.",
        'default': False
    },
    {
        'long': '--run-id',
        'dest': 'run_id',
        'help': 'custom run id to use instead of generating a new GUID'
    }

]

POSITIONAL_ARGS = [
    {
        'long': 'module',
        'nargs': '*'
    }
]

# Note: the trailing space seems to be the only way to add an extra trailing line
EPILOG_STR = """\
Available Modules:

    {}

Configuration:

    Config settings can be specified in the input data, in separate config
    file(s), and as command line options.  First the input data is loaded,
    then the file files are applied, and finally the comand line settings
    are applied.  If multiple config files are specified, they will be applied
    in the order they are specified. The same holds true for settings
    specified on the command line.

    For example if input.json specifies foo=foo, config1.json specifies
    foo=bar, and config2.json specifies foo=baz, and if bsp is invoked like:

     $ bsp -i input.json -c config1.json -c config2.json

    then foo will be set to 'baz'.  If you add '-C foo=bsdf' to the command,
    then regardless of where it is specified in the command, foo will be
    'bsdf'.
 """.format('\n    '.join(modules.AVAILABLE_MODULES))

def validate_args(args):
    # TODO: validate args values as necessary
    pass

def exit_with_traceback(e):
    logging.error(e)
    logging.debug(traceback.format_exc())
    scripting.utils.exit_with_msg(e)

def output_version(parser, args):
    if args.version:
        sys.stdout.write("bsp (bluesky) version {}\n".format(__version__))
        sys.exit(0)

def load_fires(args):
    # Note: Calling code handles exception
    fires_manager = models.fires.FiresManager()
    fires_manager.loads(input_file=args.input_file)
    # run_id must be specified after the call to loads (as opposed to when
    # instantiatiing fires_manager) - otherwise, loads will delete it
    # (since loads wipes fires_manager and then populates it from scratch).
    # If run_id is defined in both the input file and in args.run_id, an
    # exception will be raised, since run_id can only be set once (with the
    # exception of being able to be reset in or after a call to loads).
    if args.run_id:
        fires_manager.run_id = args.run_id
    return fires_manager

def main():
    parser, args = scripting.args.parse_args(REQUIRED_ARGS, OPTIONAL_ARGS,
        positional_args=POSITIONAL_ARGS, epilog=EPILOG_STR,
        pre_validation=output_version)
    validate_args(args)
    #scripting.utils.log_config(args.config_options)

    try:
        fires_manager = load_fires(args)
        # modules may be specified either in the input json or as command line
        # args, but not in both places
        if args.module:
            if fires_manager.modules:
                raise RuntimeError("Modules to be run can't be specified both"
                " on the command line and in the input json")
            fires_manager.modules = args.module

        # TODO: uncomment/enable '-D'/'--contig-option' and merge the config
        #  values specified in args.config_options into config. First refactor
        #  that option to produce nested dict rather than a ConfigParser object
        #  object.  Make sure output json contains merged config (with tests)
        # TODO: uncomment/enable '-c'/'--config-file' option, load into
        #  ConfigParser object, convert that object into a dict, and merge that
        #  dict into config.  Make sure output json contains merged config
        #  (with tests)

        # merge loaded file options
        fires_manager.merge_config(args.config_file_options)
        fires_manager.merge_config(args.config_options)

        fires_manager.run()
    except exceptions.BlueSkyModuleError, e:
        # The error was added to fires_manager's meta data, and will be
        # included in the output data
        pass
    except Exception, e:
        exit_with_traceback(e)

    fires_manager.dumps(output_file=args.output_file)

if __name__ == "__main__":
    main()
